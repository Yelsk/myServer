# 问题和改进

1. 考虑使用RAII封装互斥锁和定时器，避免编写过程中产生内存泄漏
2. 考虑使用条件变量代替信号量，简化设计
3. 考虑用智能指针代替原始指针，不需要delete
4. 考虑加入log功能，方便调试以及运行过程中的错误记载
5. 目前关闭连接只是单纯的close()，应根据不同的情况采取不同策略，实现优雅关闭
6. 考虑某些类使用单例模式，节约系统资源

##### 小笔记：

EPOLLONESHOT (since Linux 2.6.2)
           Sets the one-shot behavior for the associated file descriptor. This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is **internally disabled and no other events will be reported by the epoll interface**.  The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask.



Q6  Will closing a file descriptor cause it to be removed from all epoll sets automatically?

A6  Yes, but be aware of the following point.  A file descriptor is a reference to an open file description (see open(2)).  Whenever a file descriptor is duplicated via dup(2), dup2(2), fcntl(2) F_DUPFD, or fork(2), a new file descriptor referring to the same open file description is created.  An open file description continues to exist until all file descriptors referring to it have been closed.  **A file descriptor is removed from an epoll set only after all the file descriptors referring to the underlying open file description have been closed (or before if the file descriptor is explicitly removed using epoll_ctl(2) EPOLL_CTL_DEL).** This means that even after a file descriptor that is part of an epoll set has been closed, events may be reported for that file descriptor if other file descriptors referring to the same underlying file description remain open.

当调用close()关闭对应的fd时，会使相应的引用计数减一，只有减到0时，epoll才会真的删掉它，所以，比较安全的做法是：先del掉它，再close它(如果不确定close是否真的关闭了这个文件。)。